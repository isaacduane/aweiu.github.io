<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> IE8兼容记—完美模拟oninput · 阿伟的博客</title><meta name="description" content="IE8兼容记—完美模拟oninput - 余阿伟"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="http://awei.oss-cn-shenzhen.aliyuncs.com/libs.html" target="_blank" class="nav-list-link">JSLIBS</a></li><li class="nav-list-item"><a href="https://github.com/awei-yu" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">IE8兼容记—完美模拟oninput</h1><div class="post-time">2016年4月26日</div><div class="post-content"><p>　　哈喽，前端的小伙伴们！在聊今天的IE兼容之前，还是先跟我一起问候下(日了)ie的所有版本吧！<br>　　在现代浏览器中，对表单元素的输入监听一般是通过监听”input”事件来实现，但坑爹的是ie8及之前的版本是不支持这个事件的,基本会使用它的替代品——“propertychange”来模拟这个事件，但模拟总归是模拟，如下是我总结的它们之间的最大区别<br><a id="more"></a></p>
<h1 id="propertychange和input的区别"><a href="#propertychange和input的区别" class="headerlink" title="propertychange和input的区别"></a>propertychange和input的区别</h1><ol>
<li>propertychange的触发条件并不仅仅是输入框的value被改变,任何属性的改变都会触发(比如:class,attribute等)</li>
<li>propertychange事件不会冒泡，也就是说不能够像oninput那样进行事件托管</li>
<li>propertychange事件并不区分事件的调用来源，用户输入会触发，js改变也会触发。而”input”事件往往都只需要关注用户的输入，这就容易造成事件的误触发</li>
</ol>
<p>ok，下面来针对上面的每一条来一一给出解决办法，实现完美模拟！(全网独家!)<br></p>
<h1 id="一-让propertychange只关注”value”变化"><a href="#一-让propertychange只关注”value”变化" class="headerlink" title="一.让propertychange只关注”value”变化"></a>一.让propertychange只关注”value”变化</h1><p><em>这里的value是个泛指，如果监听对象是select(下拉选框)，它的value就是selectedIndex</em></p>
<p>上代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input.onpropertychange=function(e)&#123;</span><br><span class="line">    if(e.propertyName == &quot;value&quot; || e.propertyName == &quot;selectedIndex&quot;)&#123;</span><br><span class="line">        //这里写事件处理即可</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可以看出propertychange触发的事件对象中有属性”propertyName”，它代表的含义是本次是表单元素的哪个属性被改变了，对它进行过滤来实现模拟1</p>
<h1 id="二-让propertychange事件冒泡"><a href="#二-让propertychange事件冒泡" class="headerlink" title="二.让propertychange事件冒泡"></a>二.让propertychange事件冒泡</h1><p>　　这个需要是否有点强IE8所难呢？的确，该事件本身是并不支持的，那我们只能想点歪门斜道了，通过监听”focusin”来变通实现<br><br>实现思路如下:</p>
<p>　　这种需求一般是想要进行事件托管，通过监听表单元素的父级或者document/window对象来方便托管一切表单元素，这种实现方式稳定又高效，但这一切是基于该事件能够冒泡到顶层。虽然propertychange事件不支持冒泡，但”focusin”事件是支持的不过它俩的职责不同啊，一个是监听属性变化，一个是监听焦点变化，如何联系？</p>
<p>　　大家想一下，如果要模拟input事件，一切的事件触发都是基于用户的输入，但输入之前必然得先让表单元素获取焦点，那是否可以这样，当输入框获取焦点的时候再绑定propertychange呢？</p>
<p>上代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.onfocusin=function(e)&#123;</span><br><span class="line">    //target即为此时获取焦点的元素</span><br><span class="line">    var target=e.srcElement;</span><br><span class="line">    //这里再保证一下此时该元素确实获取焦点(focusin事件也有坑爹的地方，暂且不表)</span><br><span class="line">    if(document.activeElement == target)&#123;</span><br><span class="line">        target.onpropertychange=function(e)&#123;</span><br><span class="line">            if(e.propertyName == &quot;value&quot; || e.propertyName == &quot;selectedIndex&quot;)&#123;</span><br><span class="line">                //这里写事件处理即可</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="三-让propertychange过滤js对值的改变"><a href="#三-让propertychange过滤js对值的改变" class="headerlink" title="三.让propertychange过滤js对值的改变"></a>三.让propertychange过滤js对值的改变</h1><p>　　这条我觉得才是重头戏！网上也有相关实现，但解决方案无非两种:</p>
<ol>
<li>干脆就不监听propertychange，通过监听表单元素的”keydown”,”cut”,”paste”等一系列输入事件来模拟</li>
<li>在js设置value之前先主动告诉某变量我正在用js改变value，propertychange于是忽略。于是你在每次用js设置值之前都得先设置那个全局变量先</li>
</ol>
<p>　　好吧，我就不喷了，直接上我的解决办法，通过使用大家很少会用到的api:<a href="http://www.2cto.com/kf/201410/346904.html" target="_blank" rel="external">defineProperty(点我查看用途)</a></p>
<p>　　如果你已经了解了defineProperty，我估计你已经知道我接下来要干啥了。</p>
<p>　　其实思路说出来很简单，就是如果在js改变表单元素值的时候，能自动通知我不就完事大吉了吗？而defineProperty就是干这事的！啊，不对，应该是一不小心干了这事。。</p>
<p><strong>错误代码如下，错误代码如下，错误代码如下(重要的事情说三遍)</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs</span><br><span class="line">var setValByJs=false;</span><br><span class="line">Object.defineProperty(input,&quot;value&quot;,&#123;</span><br><span class="line">    set:function(val)&#123;</span><br><span class="line">        this.value=val;</span><br><span class="line">        setValByJs=true;</span><br><span class="line">    &#125;,</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.onpropertychange=function(e)&#123;</span><br><span class="line">    if(e.propertyName == &quot;value&quot; || e.propertyName == &quot;selectedIndex&quot;)&#123;</span><br><span class="line">        if(setValByJs)&#123;</span><br><span class="line">            setValByJs=false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //这里写事件处理即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　为什么上面的代码是错的？因为会无限递归(好一个自问自答==)。由代码可以看出，在set方法的内部又调用了this.value=xx,于是就会继续再调用set，所以无限递归了。为毛非得”this.value=xx”呢，因为不这样的话，项目中的如下代码就会彻底失效了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input.value=&quot;我是单身狗，汪汪汪&quot;;</span><br></pre></td></tr></table></figure></p>
<p>方法总比困难多，机智的我又想到另外一种设置value的办法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input.setAttribute(&quot;value&quot;,&quot;我是单身狗，汪汪汪&quot;);</span><br></pre></td></tr></table></figure></p>
<p>ok,那再修改一下上面的代码</p>
<p><strong>还是错误代码如下，错误代码如下，错误代码如下(重要的事情说三遍)</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs</span><br><span class="line">var setValByJs=false;</span><br><span class="line">Object.defineProperty(input,&quot;value&quot;,&#123;</span><br><span class="line">    set:function(val)&#123;</span><br><span class="line">        this.setAttribute(&quot;value&quot;,val);</span><br><span class="line">        setValByJs=true;</span><br><span class="line">    &#125;,</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this.getAttribute(&quot;value&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.onpropertychange=function(e)&#123;</span><br><span class="line">    if(e.propertyName == &quot;value&quot; || e.propertyName == &quot;selectedIndex&quot;)&#123;</span><br><span class="line">        if(setValByJs)&#123;</span><br><span class="line">            setValByJs=false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //这里写事件处理即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　那么问题来了，为毛上面的代码还错啊？！我特么又要自言自语了。.听我仔细分析:<br>　　当js对表单元素设置值的时候，首先会触发defineProperty中对value定义的set方法，然后代码走啊走啊，当走到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setAttribute(&quot;value&quot;,val);</span><br></pre></td></tr></table></figure></p>
<p>　　这一行的时候，代码就会立刻跳到input.onpropertychange方法中去。。也就是说你还没来得及设置setValByJs呢，事件就被捕获了,故而对于托管方法来说，setValByJs的值是啥永远是后知后觉的。为什么我会了解这么清楚？好吧，这都是我那时候遇到的坑，出于大家坑才是真的坑的心态，故放出来大家一起坑。所以上面的代码只需要把:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setValByJs=true</span><br></pre></td></tr></table></figure></p>
<p>　　移到set方法的第一行即可。。</p>
<p><strong>基本正确的代码如下</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs</span><br><span class="line">var setValByJs=false;</span><br><span class="line">Object.defineProperty(input,&quot;value&quot;,&#123;</span><br><span class="line">    set:function(val)&#123;</span><br><span class="line">        setValByJs=true;</span><br><span class="line">        this.setAttribute(&quot;value&quot;,val);</span><br><span class="line">    &#125;,</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this.getAttribute(&quot;value&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.onpropertychange=function(e)&#123;</span><br><span class="line">    if(e.propertyName == &quot;value&quot; || e.propertyName == &quot;selectedIndex&quot;)&#123;</span><br><span class="line">        if(setValByJs)&#123;</span><br><span class="line">            setValByJs=false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //这里写事件处理即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　为什么又是基本正确呢？因为以上的例子基本全是事件的单一绑定，多绑定的坑还有很多。<br>这里提一点最容易被坑的吧,就是这段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(setValByJs)&#123;</span><br><span class="line">    setValByJs=false;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //这里写事件处理即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　如果该表单元素的propertychange事件绑定了多个监听方法，只有第一个方法里会获取到setValByJs的正确值，后面的获取到的永远都是false.大家好好看下代码便知原因。这种情况也是得用点歪门斜道解决:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(setValByJs)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        setValByJs=false;</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //这里写事件处理即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　而且以上代码没有覆盖到所有表单元素，比如上文中提到的下拉选择框，它一般不直接监听”value”，不过核心思路都在这了，希望对你有用！希望世上再没有IE！阿门</p>
<div class="tip">　<br>    其实之前有写过IE8兼容插件<a href="https://github.com/awei-yu/JsLibs" target="_blank" rel="external">fixJSForIE8</a>通过它可以让ie8兼容各种js的新特性并无须更改现有代码。只是目前该插件正在重构中，老的版本还并不能完美模拟”oninput”以及写得很烂。。着急的话可以先凑合用。主要目前缺少IE8的测试机器(不想装虚拟机)一旦更新，我会推送的。那就关注我的git吧~<br></div></div></article></div></section><footer><div class="paginator"><a href="/2016/04/18/喜马拉雅黑科技——无卡顿网页播放器/" class="next">NEXT</a></div><div data-thread-key="2016/04/26/IE8兼容记—完美模拟oninput/" data-title="IE8兼容记—完美模拟oninput" data-url="http://yoursite.com/2016/04/26/IE8兼容记—完美模拟oninput/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"seansun"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">余阿伟</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>