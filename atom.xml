<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿伟的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aweiu.com/"/>
  <updated>2016-05-06T02:48:35.177Z</updated>
  <id>http://aweiu.com/</id>
  
  <author>
    <name>余阿伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>seajs进阶小记</title>
    <link href="http://aweiu.com/2016/05/06/seajs%E8%BF%9B%E9%98%B6%E5%B0%8F%E8%AE%B0/"/>
    <id>http://aweiu.com/2016/05/06/seajs进阶小记/</id>
    <published>2016-05-06T02:09:37.000Z</published>
    <updated>2016-05-06T02:48:35.177Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章是很久之前写在csdn上的,现在迁移过来。总有些问题是你百度都不知道怎么打关键字的问题，本文内容就是关于seajs的一些边边角角，希望能够帮到你&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;单例模式的解决方案&quot;&gt;&lt;a href=&quot;#单例模式的解决方案&quot; class=&quot;headerlink&quot; title=&quot;单例模式的解决方案&quot;&gt;&lt;/a&gt;单例模式的解决方案&lt;/h2&gt;&lt;p&gt;js模块化开发的好处就不啰嗦了，但世上没有什么事物是完美的，无论是requireJs或是seaJs。其实完美这个词也是相对来说得，可能和每个人的设计思路，设计模式都有关系。&lt;br&gt;就拿本文即将说的所谓seajs的单例模式。就是无论你在页面的什么地方，哪个js文件里面，只要require/use的是同一个js,那么它们真的就是同一个。。。当初自己还傻傻地在一个模块里这么写过:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a1=require(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a2=require(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a1.x=&amp;quot;你又在装逼了？&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a2.x=&amp;quot;不装逼我浑身难受!&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	alert(a1.x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	alert(a2.x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果:&lt;br&gt;两个sb弹窗都在叫着:”不装逼我浑身难受”！说好的a1,a2呢？吓得我差点报警。&lt;/p&gt;
&lt;p&gt;又进行了一番测试，a模块的内容如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	alert(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你会发现,哪怕你require一万次a，弹窗也只会出现1次哦~真得就出现1次哦~&lt;br&gt;而且提醒一下下:require也好，use也罢，对应的js文件都只会下载一遍！所以，不要担心同一个js文件多次require会消耗大量的网络资源导致的效率问题。&lt;br&gt;后来仔细一琢磨，这可能就是模块化开发的特点吧——单例模式，用它就忍着吧。。&lt;br&gt;问题是机智的我能忍吗？一点也不能惯着！而且原生JS也表示不服，说我特么好不容易发明出来的prototype，this，还有call等等这些能够让单身狗愉快地new一个对象的技能就这么被干掉了？弄得我好像是低级语言一样。。。（此处应有笑声）&lt;br&gt;上面这个需求如果不用seajs的话肯定是难不倒小伙伴们的:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function a()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a1=new a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a2=new a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//......后面自行脑补。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当初搜遍了网络，几乎没有发现过有类似的问题，更别提解决方案了，很是头疼，这也可能和本人的编程习惯有关，单例固然是好，但有时候实现某些需求得绕很大的弯子，敲一堆代码，这对于完美主义强迫症的我来说真真是个悲剧。。。&lt;br&gt;假设上面的a.js是我写的一个seajs模块，它是一个表格分页插件。在require了之后，我需要对其进行一些初始化的配置(绑定表格,设置回调等等)。那么问题来了，如果当前页面上只有一个分页表格一切都好说，该怎么配置插件就怎么配置，那么多个表格呢？我每次调用其方法都把对应的配置给传过去？说实话，我干不出这种蠢事。。于是好戏来了，如果你给a模块内部”exports”上下面这个神奇的函数，包你腰不酸了，腿不疼了，敲起代码也更有劲了&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//hi~我是随便找个地方插进来的new方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exports.newInstance = function (fuc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fuc += &amp;quot;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (fuc.indexOf(&amp;quot;\nexports=this;&amp;quot;) == -1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fuc = (&amp;quot;0,(&amp;quot; + fuc + &amp;quot;)&amp;quot;).replace(&amp;quot;&amp;#123;&amp;quot;, &amp;quot;&amp;#123;\nexports=this;&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var p = /([\s;=]+require\s*\([\s\S]*?\))/g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fuc = fuc.replace(p, &amp;quot;$1.newInstance()&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                p = /( *\. *newInstance *\( *\))&amp;#123;2&amp;#125;/g;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fuc = fuc.replace(p, &amp;quot;.newInstance()&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return new (eval(fuc))(require,exports, module);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;(arguments.callee);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;别问为什么，看上去有点蒙，仔细一琢磨，卧槽！原来是酱紫啊！就对了，我的装逼目的也就达到了。&lt;br&gt;于是a模块的多例使用代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a1=require(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a2=a1.newInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a1.doSth();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a2.doSth();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//......后面自行脑补&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;通过本函数newInstance出来的模块如果内部还有依赖，你得给它依赖的模块也实现一个newInstance方法，大家new才是真的new，这样出来的模块才是干干净净地，完全独立的模块。当然了，某些依赖链里的模块可能真得不需要重新创建实例，本着浪费就是可耻的原则，你可以把它的newInstance方法这么写:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//hi~我是随便找个地方插进来的不会创建新实例的new方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exports.newInstance= function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return exports;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;模块记载机制&quot;&gt;&lt;a href=&quot;#模块记载机制&quot; class=&quot;headerlink&quot; title=&quot;模块记载机制&quot;&gt;&lt;/a&gt;模块记载机制&lt;/h2&gt;&lt;p&gt;千万别天真的以为你在模块里面这样:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//不要在意a,b,c,d这种命名方式。。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a=require(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var b=require(&amp;quot;b&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就天真地以为,这个模块会加载完a模块之后再加载b模块。。&lt;br&gt;真相其实是这样的:&lt;br&gt;在一个模块里面,require语句的优先级是最高的，无论你将它放在模块的任意位置会优先执行require。&lt;br&gt;注意，优先执行require不代表你可以这么写:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	alert(a.x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var a=require(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a.x=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除非a.js是个三方插件或者a模块不对外提供任何方法和属性，仅仅是用于给页面来点特效啦，加载一些数据啦等，和代码的下文没有什么关系的事情，你大可以把require(“a”)放在任何地方，也就没必要将其赋值给某个变量了。&lt;br&gt;比如:&lt;br&gt;a.js的内容如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//a.js的全部代码就这一行 是一个并没有遵循seajs规范的三方插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个依赖a模块的模块内容如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;quot;t&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    require(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果你会发现弹窗内容果然先是”a”，后是”t”;&lt;br&gt;值得注意的是seajs还有一种模块加载方法是use，它的加载时机就得看你把它写在什么地方了。&lt;br&gt;接上文的那个依赖a模块的模块内容如果是这么写:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;quot;t&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    seajs.use(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这次的执行结果就是先”t”后”a”了。&lt;br&gt;关于上面这一点，后面我会继续说。&lt;br&gt;言归正传，a和b到底谁先加载,我可以肯定地告诉你，确实是a先加载，但是！恩，但是来了。但是a和b谁先加载完就得看各自的造化了，或是因为网络原因，或是因为文件大小，意思就是说你require的模块它们之间一定不要有啥耦合关系，否则很有可能会因为加载的先后顺序导致一些异常，不过话又说回来，如果你严格按照seajs的规范来设计模块的话这种事问题肯定不会出现的，各个模块内部都有独立的作用域和其明确的依赖链嘛。。&lt;/p&gt;
&lt;p&gt;举一反四：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;a&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;b&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;a和b的加载情况和上述是一样一样的。&lt;/p&gt;
&lt;h2 id=&quot;如何使用非seajs插件&quot;&gt;&lt;a href=&quot;#如何使用非seajs插件&quot; class=&quot;headerlink&quot; title=&quot;如何使用非seajs插件&quot;&gt;&lt;/a&gt;如何使用非seajs插件&lt;/h2&gt;&lt;p&gt;不得不承认，目前的seajs插件少得令人发指！(&lt;a href=&quot;http://awei.oss-cn-shenzhen.aliyuncs.com/libs.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;现在有seajs插件集了,点我查看&lt;/a&gt;)在实际开发过程中，总会用到各种各样五颜六色的插件，它们不是jquery插件就是jquery插件！咱们不可能说一个项目当中的所有插件都自己用seajs的规范再重复造一个吧？不说时间够不够了，就算够，你造出来之后总得优化，总得调bug吧？哪有直接用市面上已经现成的，修炼多年的插件来得爽快？就算你还是说，不行！我就是喜欢重复造轮子！我就是觉得自己写的插件是最好的，别人的就是垃圾！shit！哥们，我太喜欢你了，其实你和我一样，我还真是不喜欢用别人的插件，不说别人写得好不好吧，其实主要讨厌还得去看他们出的文档，我打死都不会承认我看不懂某些充满了浓浓装逼气息的api文档的。。我靠，我又说废话了！&lt;/p&gt;
&lt;p&gt;结合上文说的seajs加载机制，如果想要使用三方插件，比如:jquery-table-xxx.js,显然，它是一个jQuery插件，而且显然还依赖jquery-table.js。&lt;/p&gt;
&lt;p&gt;也就是有了如下依赖关系:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jquery-table-xxx依赖jquery-table&lt;/li&gt;
&lt;li&gt;jquery-table依赖jquery&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设jquery.js内容如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var a=1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;jquery-table内容如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var b=a+1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; jquery-table-xxx内容如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var c=b+1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;主js内容如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;seajs.use(&amp;quot;jquery&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;jquery-table&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		seajs.use(&amp;quot;jquery-table-xxx&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(c);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;思考:&lt;/strong&gt; 主js的运行结果一定是3吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思考结束，答案是也许是3。一定要搞明白一点，主js中的alert语句虽然一定会在jquery-table-xxx.js加载之后执行，但不一定是jquery-table-xxx.js加载完毕之后执行！加载之后，加载完毕之后是不一样滴~骚年！。只有这点搞懂了，才会知道为什么seajs的项目中使用三方插件会出现一些随机错误！什么？你问为什么不在各个js文件里require各自的依赖？都说了别人写的插件，并没有遵循seajs规范，你也就不能使用require了！懂？&lt;/p&gt;
&lt;p&gt;肯定有小伙伴会说，如果主js这么写:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;seajs.use(&amp;quot;jquery&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;jquery-table&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		seajs.use(&amp;quot;jquery-table-xxx&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			alert(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不就完事大吉了吗？是的。。但是你不觉得这种嵌套太变态了么。而且如果除了上述的三个插件，再来些插件:lalala.js,lalala-xxx.js，你单纯use的话。。。&lt;/p&gt;
&lt;p&gt;主js要这样吗？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;seajs.use(&amp;quot;jquery&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;jquery-table&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		seajs.use(&amp;quot;jquery-table-xxx&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			seajs.use(&amp;quot;lalala&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				seajs.use(&amp;quot;lalala-xxx&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					alert(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					//这里省略使用lalala-xxx模块的代码。。编不下去了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;卧槽！！哈哈，而且重点是lalala,lalala-xxx和另外三个js是没有半毛钱关系的，凭什么要它俩等那三个加载完毕再加载？效率呢？&lt;/p&gt;
&lt;p&gt;那么主js要这样吗？&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;seajs.use(&amp;quot;jquery&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;jquery-table&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		seajs.use(&amp;quot;jquery-table-xxx&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			alert(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;seajs.use(&amp;quot;lalala&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	seajs.use(&amp;quot;lalala-xxx&amp;quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//这里省略使用lalala-xxx模块的代码。。编不下去了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不错，加载效率是上去了，那么代码的可读性呢？业务逻辑代码会被这些加载代码给拆得七零八落&lt;/p&gt;
&lt;p&gt;于是下面我要写的就是一个能够让小伙伴们愉快地使用三方插件的插件。。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开记事本(都是装逼界的同仁，你就当做我打开的是记事本呗)&lt;/li&gt;
&lt;li&gt;新建文件-&amp;gt;superUse.js(是时候来个响亮的名字亮瞎你们了)&lt;/li&gt;
&lt;li&gt;内容如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var newUse = function (array, fuc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.num = array.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.fuc = fuc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (var i = 0; i &amp;lt; array.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            this.loadJs(array[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    newUse.prototype.loadJs = function (array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var that = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (typeof(array) == &amp;quot;string&amp;quot;) array = [array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var callBac=(array.length == 1?function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (--that.num == 0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (that.fuc)that.fuc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            array.shift();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            that.loadJs(array);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        seajs.use(array[0],callBac);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exports.use = function (array, fuc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new newUse(array, fuc);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用示例:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;define(function (require, exports, module) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	var superUse=require(&amp;quot;superUse&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	superUse.use([&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;a&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[&amp;quot;e&amp;quot;,&amp;quot;f&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	],function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		alert(&amp;quot;所有js全部加载完毕的回调函数&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//参数1(数组):[&amp;quot;a&amp;quot;,[&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;],[&amp;quot;e&amp;quot;,&amp;quot;f&amp;quot;]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//a是个独立的三方js插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//c依赖b为一个三方插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//f依赖e为一个三方插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//它们三个会同时按照各自的组内的依赖关系同时加载。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//参数2(function):function()&amp;#123;alert(&amp;quot;所有js全部加载完毕的回调函数&amp;quot;);&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//表示上述的js全部加载完毕之后会执行该回调函数，建议把业务逻辑代码全部丢进去，这样能够保证它们的执行是在三方插件全部加载完毕之后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好消息！好消息！根据以上逻辑，现在已经有插件实现该use方法了，而且更加强大，支持动态use更多静态资源(js,css,html)&lt;br&gt;&lt;a href=&quot;https://github.com/aweiu/JsLibs/wiki/seajs-utils(%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/aweiu/JsLibs/wiki/seajs-utils(%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86&lt;/a&gt;)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是很久之前写在csdn上的,现在迁移过来。总有些问题是你百度都不知道怎么打关键字的问题，本文内容就是关于seajs的一些边边角角，希望能够帮到你&lt;br&gt;
    
    </summary>
    
    
      <category term="seajs单例模式" scheme="http://aweiu.com/tags/seajs%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="seajs模块加载机制" scheme="http://aweiu.com/tags/seajs%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="使用非seajs插件" scheme="http://aweiu.com/tags/%E4%BD%BF%E7%94%A8%E9%9D%9Eseajs%E6%8F%92%E4%BB%B6/"/>
    
      <category term="seajs多实例" scheme="http://aweiu.com/tags/seajs%E5%A4%9A%E5%AE%9E%E4%BE%8B/"/>
    
      <category term="seajs入门" scheme="http://aweiu.com/tags/seajs%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>IE8兼容记—完美模拟oninput</title>
    <link href="http://aweiu.com/2016/04/26/IE8%E5%85%BC%E5%AE%B9%E8%AE%B0%E2%80%94%E5%AE%8C%E7%BE%8E%E6%A8%A1%E6%8B%9Foninput/"/>
    <id>http://aweiu.com/2016/04/26/IE8兼容记—完美模拟oninput/</id>
    <published>2016-04-26T07:07:38.000Z</published>
    <updated>2016-04-27T15:19:53.910Z</updated>
    
    <content type="html">&lt;p&gt;　　哈喽，前端的小伙伴们！在聊今天的IE兼容之前，还是先跟我一起问候下(日了)ie的所有版本吧！&lt;br&gt;　　在现代浏览器中，对表单元素的输入监听一般是通过监听”input”事件来实现，但坑爹的是ie8及之前的版本是不支持这个事件的,基本会使用它的替代品——“propertychange”来模拟这个事件，但模拟总归是模拟，如下是我总结的它们之间的最大区别&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;propertychange和input的区别&quot;&gt;&lt;a href=&quot;#propertychange和input的区别&quot; class=&quot;headerlink&quot; title=&quot;propertychange和input的区别&quot;&gt;&lt;/a&gt;propertychange和input的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;propertychange的触发条件并不仅仅是输入框的value被改变,任何属性的改变都会触发(比如:class,attribute等)&lt;/li&gt;
&lt;li&gt;propertychange事件不会冒泡，也就是说不能够像oninput那样进行事件托管&lt;/li&gt;
&lt;li&gt;propertychange事件并不区分事件的调用来源，用户输入会触发，js改变也会触发。而”input”事件往往都只需要关注用户的输入，这就容易造成事件的误触发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ok，下面来针对上面的每一条来一一给出解决办法，实现完美模拟！(全网独家!)&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-让propertychange只关注”value”变化&quot;&gt;&lt;a href=&quot;#一-让propertychange只关注”value”变化&quot; class=&quot;headerlink&quot; title=&quot;一.让propertychange只关注”value”变化&quot;&gt;&lt;/a&gt;一.让propertychange只关注”value”变化&lt;/h1&gt;&lt;p&gt;&lt;em&gt;这里的value是个泛指，如果监听对象是select(下拉选框)，它的value就是selectedIndex&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上代码可以看出propertychange触发的事件对象中有属性”propertyName”，它代表的含义是本次是表单元素的哪个属性被改变了，对它进行过滤来实现模拟1&lt;/p&gt;
&lt;h1 id=&quot;二-让propertychange事件冒泡&quot;&gt;&lt;a href=&quot;#二-让propertychange事件冒泡&quot; class=&quot;headerlink&quot; title=&quot;二.让propertychange事件冒泡&quot;&gt;&lt;/a&gt;二.让propertychange事件冒泡&lt;/h1&gt;&lt;p&gt;　　这个需要是否有点强IE8所难呢？的确，该事件本身是并不支持的，那我们只能想点歪门斜道了，通过监听”focusin”来变通实现&lt;br&gt;&lt;br&gt;实现思路如下:&lt;/p&gt;
&lt;p&gt;　　这种需求一般是想要进行事件托管，通过监听表单元素的父级或者document/window对象来方便托管一切表单元素，这种实现方式稳定又高效，但这一切是基于该事件能够冒泡到顶层。虽然propertychange事件不支持冒泡，但”focusin”事件是支持的。不过它俩的职责不同啊，一个是监听属性变化，一个是监听焦点变化，如何联系？&lt;/p&gt;
&lt;p&gt;　　大家想一下，如果要模拟input事件，一切的事件触发都是基于用户的输入，但输入之前必然得先让表单元素获取焦点，那是否可以这样，当输入框获取焦点的时候再绑定propertychange呢？&lt;/p&gt;
&lt;p&gt;上代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;document.onfocusin=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //target即为此时获取焦点的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var target=e.srcElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里再保证一下此时该元素确实获取焦点(focusin事件也有坑爹的地方，暂且不表)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(document.activeElement == target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;三-让propertychange过滤js对值的改变&quot;&gt;&lt;a href=&quot;#三-让propertychange过滤js对值的改变&quot; class=&quot;headerlink&quot; title=&quot;三.让propertychange过滤js对值的改变&quot;&gt;&lt;/a&gt;三.让propertychange过滤js对值的改变&lt;/h1&gt;&lt;p&gt;　　这条我觉得才是重头戏！网上也有相关实现，但解决方案无非两种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;干脆就不监听propertychange，通过监听表单元素的”keydown”,”cut”,”paste”等一系列输入事件来模拟&lt;/li&gt;
&lt;li&gt;在js设置value之前先主动告诉某变量我正在用js改变value，propertychange于是忽略。于是你在每次用js设置值之前都得先设置那个全局变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　好吧，我就不喷了，直接上我的解决办法，通过使用大家很少会用到的api:&lt;a href=&quot;http://www.2cto.com/kf/201410/346904.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;defineProperty(点我查看用途)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果你已经了解了defineProperty，我估计你已经知道我接下来要干啥了。&lt;/p&gt;
&lt;p&gt;　　其实思路说出来很简单，就是如果在js改变表单元素值的时候，能自动通知我不就完事大吉了吗？而defineProperty就是干这事的！啊，不对，应该是一不小心干了这事。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误代码如下，错误代码如下，错误代码如下(重要的事情说三遍)&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(input,&amp;quot;value&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    set:function(val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.value=val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　为什么上面的代码是错的？因为会无限递归(好一个自言自语==)。由代码可以看出，在set方法的内部又调用了this.value=xx,于是就会继续再调用set，所以无限递归了。为毛非得”this.value=xx”呢，因为不这样的话，项目中的如下代码就会彻底失效了:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input.value=&amp;quot;我是单身狗，汪汪汪&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方法总比困难多，机智的我又想到另外一种设置value的办法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input.setAttribute(&amp;quot;value&amp;quot;,&amp;quot;我是单身狗，汪汪汪&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ok,那再修改一下上面的代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还是错误代码如下，错误代码如下，错误代码如下(重要的事情说三遍)&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(input,&amp;quot;value&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    set:function(val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.setAttribute(&amp;quot;value&amp;quot;,val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.getAttribute(&amp;quot;value&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　那么问题来了，为毛上面的代码还错啊？！且听我仔细分析:&lt;br&gt;　　当js对表单元素设置值的时候，首先会触发defineProperty中对value定义的set方法，然后代码走啊走啊，当走到:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;this.setAttribute(&amp;quot;value&amp;quot;,val);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　这一行的时候，代码就会立刻跳到input.onpropertychange方法中去。。也就是说你还没来得及设置setValByJs呢，事件就被捕获了,故而对于托管方法来说，setValByJs的值是啥永远是后知后觉的。为什么我会了解这么清楚？好吧，这都是我那时候遇到的坑，出于大家坑才是真的坑的心态，故放出来大家一起坑。所以上面的代码只需要把:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setValByJs=true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　移到set方法的第一行即可。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本正确的代码如下&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(input,&amp;quot;value&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    set:function(val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.setAttribute(&amp;quot;value&amp;quot;,val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.getAttribute(&amp;quot;value&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　为什么又是基本正确呢？因为以上的例子基本全是事件的单一绑定，多绑定的坑还有很多。&lt;br&gt;这里提一点最容易被坑的吧,就是这段代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　如果该表单元素的propertychange事件绑定了多个监听方法，只有第一个方法里会获取到setValByJs的正确值，后面的获取到的永远都是false.大家好好看下代码便知原因。这种情况也是得用点歪门斜道解决:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　而且以上代码没有覆盖到所有表单元素，比如上文中提到的下拉选择框，它一般不直接监听”value”，不过核心思路都在这了，希望对你有用！希望世上再没有IE！阿门&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;　&lt;br&gt;    其实之前有写过IE8兼容插件&lt;a href=&quot;https://github.com/aweiu/JsLibs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fixJSForIE8&lt;/a&gt;通过它可以让ie8兼容各种js的新特性并无须更改现有代码。只是目前该插件正在重构中，老的版本还并不能完美模拟”oninput”以及写得很烂。。着急的话可以先凑合用。主要目前缺少IE8的测试机器(不想装虚拟机)一旦更新，我会推送的。那就关注我的git吧~&lt;br&gt;&lt;/div&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;　　哈喽，前端的小伙伴们！在聊今天的IE兼容之前，还是先跟我一起问候下(日了)ie的所有版本吧！&lt;br&gt;　　在现代浏览器中，对表单元素的输入监听一般是通过监听”input”事件来实现，但坑爹的是ie8及之前的版本是不支持这个事件的,基本会使用它的替代品——“propertychange”来模拟这个事件，但模拟总归是模拟，如下是我总结的它们之间的最大区别&lt;br&gt;
    
    </summary>
    
    
      <category term="IE8兼容" scheme="http://aweiu.com/tags/IE8%E5%85%BC%E5%AE%B9/"/>
    
      <category term="IE8监听oninput" scheme="http://aweiu.com/tags/IE8%E7%9B%91%E5%90%AConinput/"/>
    
      <category term="propertychange忽略js" scheme="http://aweiu.com/tags/propertychange%E5%BF%BD%E7%95%A5js/"/>
    
  </entry>
  
  <entry>
    <title>喜马拉雅黑科技——无卡顿网页播放器</title>
    <link href="http://aweiu.com/2016/04/18/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85%E9%BB%91%E7%A7%91%E6%8A%80%E2%80%94%E2%80%94%E6%97%A0%E5%8D%A1%E9%A1%BF%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://aweiu.com/2016/04/18/喜马拉雅黑科技——无卡顿网页播放器/</id>
    <published>2016-04-18T07:04:55.000Z</published>
    <updated>2016-04-21T03:00:17.268Z</updated>
    
    <content type="html">&lt;p&gt;　　某天上班，偶然打开网页版的喜马拉雅，随手点了首推荐音频。。。于是伴随着动词大词，动词大词，继续逛着它的首页。&lt;br&gt;　　一个不小心，又点进了老郭的相声，哎，还是木有更新，不过老段子也可以再听听，正当老夫要点播的时候，突然！哎呀！卧槽！卧槽！牛逼啊！我都逛了这么多页面了，耳机里的”动词大词”竟然连顿都没打，当时还打开了一下本地播放器，以为是它播放的音乐。&lt;br&gt;　　详细情形是这样的：我在喜马拉雅的&lt;strong&gt;a页面&lt;/strong&gt;播放了音乐，然后又去&lt;strong&gt;b页面&lt;/strong&gt;，&lt;strong&gt;c页面&lt;/strong&gt;，音乐却并没有卡顿现象，稳如死狗！注意，这里说的是连卡顿都没有，不是说跳到别的页面会继续播放。&lt;br&gt;　　国内的在线音乐平台有很多，实现喜马拉雅的这种哥还是头一回见啊。大部分都是采取的本地缓存音乐进度，跳到别的页面再读取进度，继续播放，但切页面的时候肯定是会有卡顿的。所以这里给喜马拉雅的用户体验32个赞！&lt;br&gt;　　那么问题来了，这种网页播放器是如何实现的？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;　　简单点说，其实就是使用了html5的api:&lt;a href=&quot;http://www.cnblogs.com/flash3d/archive/2013/10/23/3384823.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;history.pushstate&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;页面中，所有的a标签，js对其做了点击事件的拦截，如果是支持该API的浏览器不会发生跳转，而是通过ajax请求该链接，返回结果是一串类似于如下的json:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;html&amp;quot;:&amp;quot;&amp;lt;div class=&amp;apos;xxx&amp;apos;&amp;gt;xxx&amp;lt;/div&amp;gt;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;title&amp;quot;:&amp;quot;页面标题&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;通过js将html里的内容插入到页面的指定容器中去&lt;/li&gt;
&lt;li&gt;使用histoyr.pushstate，强势插入一条浏览历史&lt;br&gt;　　于是当前浏览器的页面内容会被更新,访问地址会变成该a标签的链接，页面标题变成返回结果中的title。所以看起来就会和跳转页面一样，但实际上页面并未发生过任何跳转，至始至终都是在一个页面中进行各种ajax请求而已，所以歌曲的播放当然不会卡顿了。&lt;br&gt;　　好了，揭秘完毕！小伙伴们是不是也可以使用上述步骤来创建自己的单页应用了呢？别急，待我先喷一喷这种单页应用的缺点先！&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;需要后端配合渲染页面。区分ajax请求和浏览器请求，即如果是ajax请求页面，则返回上述json，否则正常返回整个页面内容以供跳转。&lt;/li&gt;
&lt;li&gt;需要js/css路由(某些框架就可以实现)或初次载入即加载完所有js/css，并解决冲突。&lt;br&gt;　　因为ajax请求返回的仅仅是html部分，没有也不能够包含页面对应的js/css，一旦包含了，很可能就会形成全局变量冲突，事件冲突，样式混乱等问题，请求的页面越多，问题越严重！这对于前端的小伙伴来说真是日了狗了。。没法再轻松愉快的维护各自页面各自的静态资源了，写着a页面还得操着b页面的心，遵循一堆约定。而且本人也比较反感因为使用了某些框架（比如:react.js）就要放弃html各种纯天然的写法，毕竟原生态的，才是我们最熟悉的。&lt;/li&gt;
&lt;li&gt;感觉两条太少了，凑个数行不。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&quot;tip&quot;&gt;　&lt;br&gt;    我知道，看到这里肯定有人想喷我了。时代在进步，现在前端各种mvc框架完全能够实现这种需求，为毛还嫌麻烦？我想说，每种框架都&lt;br&gt;有它的适用情景，也都有值得我们学习的地方，but！每个团队的开发模式，编程水平，项目时间都不同，适合自己的才是最好的。并且现代&lt;br&gt;浏览器的性能，人们的带宽都取得了长足的进步，有时候为了一点性能提升而要改变适合整个团队的编码习惯，是不是有点舍近求远了呢？&lt;br&gt;&lt;/div&gt;&lt;br&gt;　　而优点当然也有了，就1条！&lt;/p&gt;
&lt;p&gt;　　太特么省流量了。因为各个页面会有很多相同部分，ajax仅返回异同部分即可，所以页面的体验会更加流畅，并可以有效减少http请求。。好像不止1条，不管了。&lt;/p&gt;
&lt;p&gt;　　那么接着html原生写法的思路，有没有一种方式能够让我们不用管前后端配合，也不用鸟静态资源路由，就像做多页站点那样无痛创建单页应用呢？相信你脑海中已经出现那个古老科技了，对！就是&lt;strong&gt;iframe&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用iframe将页面包起来&lt;/li&gt;
&lt;li&gt;播放器给挪到外面去&lt;br&gt;　　　　这样iframe中的页面爱咋跳咋跳，同样也不会影响到外面播放器的运行&lt;/li&gt;
&lt;li&gt;使用html5的另一个API:history.replacestate改改浏览器地址，改改标题&lt;/li&gt;
&lt;li&gt;iframe的跳转又天然会插入一条浏览历史&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简直完美！&lt;/p&gt;
&lt;p&gt;　　利用以上原理，鄙人写了一个插件—— &lt;a href=&quot;https://github.com/328080339/JsLibs/wiki/singlePage.js%28%E6%9B%B4%E8%87%AA%E7%84%B6%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;singlePage.js(点我查看文档)&lt;/a&gt;&lt;br&gt;　　帮助大家更自然地创建单页应用，没有那么多的屁事儿，你要做的仅仅只有一步，引入它！&lt;br&gt;　　&lt;a href=&quot;http://awei.oss-cn-shenzhen.aliyuncs.com/singlePage/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查看演示(仿喜马拉雅播放器)&lt;/a&gt;
　　&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　某天上班，偶然打开网页版的喜马拉雅，随手点了首推荐音频。。。于是伴随着动词大词，动词大词，继续逛着它的首页。&lt;br&gt;　　一个不小心，又点进了老郭的相声，哎，还是木有更新，不过老段子也可以再听听，正当老夫要点播的时候，突然！哎呀！卧槽！卧槽！牛逼啊！我都逛了这么多页面了，耳机里的”动词大词”竟然连顿都没打，当时还打开了一下本地播放器，以为是它播放的音乐。&lt;br&gt;　　详细情形是这样的：我在喜马拉雅的&lt;strong&gt;a页面&lt;/strong&gt;播放了音乐，然后又去&lt;strong&gt;b页面&lt;/strong&gt;，&lt;strong&gt;c页面&lt;/strong&gt;，音乐却并没有卡顿现象，稳如死狗！注意，这里说的是连卡顿都没有，不是说跳到别的页面会继续播放。&lt;br&gt;　　国内的在线音乐平台有很多，实现喜马拉雅的这种哥还是头一回见啊。大部分都是采取的本地缓存音乐进度，跳到别的页面再读取进度，继续播放，但切页面的时候肯定是会有卡顿的。所以这里给喜马拉雅的用户体验32个赞！&lt;br&gt;　　那么问题来了，这种网页播放器是如何实现的？&lt;br&gt;
    
    </summary>
    
    
      <category term="喜马拉雅播放器" scheme="http://aweiu.com/tags/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
      <category term="单页应用" scheme="http://aweiu.com/tags/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
    
      <category term="singlePage" scheme="http://aweiu.com/tags/singlePage/"/>
    
  </entry>
  
</feed>
