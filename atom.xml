<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿伟的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aweiu.com/"/>
  <updated>2016-04-26T07:41:53.265Z</updated>
  <id>http://aweiu.com/</id>
  
  <author>
    <name>余阿伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IE8兼容记—完美模拟oninput</title>
    <link href="http://aweiu.com/2016/04/26/IE8%E5%85%BC%E5%AE%B9%E8%AE%B0%E2%80%94%E5%AE%8C%E7%BE%8E%E6%A8%A1%E6%8B%9Foninput/"/>
    <id>http://aweiu.com/2016/04/26/IE8兼容记—完美模拟oninput/</id>
    <published>2016-04-26T07:07:38.000Z</published>
    <updated>2016-04-26T07:41:53.265Z</updated>
    
    <content type="html">&lt;p&gt;　　哈喽，前端的小伙伴们！在聊今天的IE兼容之前，还是先跟我一起问候下(日了)ie的所有版本吧！&lt;br&gt;　　在现代浏览器中，对表单元素的输入监听一般是通过监听”input”事件来实现，但坑爹的是ie8及之前的版本是不支持这个事件的,基本会使用它的替代品——“propertychange”来模拟这个事件，但模拟总归是模拟，如下是我总结的它们之间的最大区别&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;propertychange和input的区别&quot;&gt;&lt;a href=&quot;#propertychange和input的区别&quot; class=&quot;headerlink&quot; title=&quot;propertychange和input的区别&quot;&gt;&lt;/a&gt;propertychange和input的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;propertychange的触发条件并不仅仅是输入框的value被改变,任何属性的改变都会触发(比如:class,attribute等)&lt;/li&gt;
&lt;li&gt;propertychange事件不会冒泡，也就是说不能够像oninput那样进行事件托管&lt;/li&gt;
&lt;li&gt;propertychange事件并不区分事件的调用来源，用户输入会触发，js改变也会触发。而”input”事件往往都只需要关注用户的输入，这就容易造成事件的误触发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ok，下面来针对上面的每一条来一一给出解决办法，实现完美模拟！(全网独家!)&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-让propertychange只关注”value”变化&quot;&gt;&lt;a href=&quot;#一-让propertychange只关注”value”变化&quot; class=&quot;headerlink&quot; title=&quot;一.让propertychange只关注”value”变化&quot;&gt;&lt;/a&gt;一.让propertychange只关注”value”变化&lt;/h1&gt;&lt;p&gt;&lt;em&gt;这里的value是个泛指，如果监听对象是select(下拉选框)，它的value就是selectedIndex&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上代码可以看出propertychange触发的事件对象中有属性”propertyName”，它代表的含义是本次是表单元素的哪个属性被改变了，对它进行过滤来实现模拟1&lt;/p&gt;
&lt;h1 id=&quot;二-让propertychange事件冒泡&quot;&gt;&lt;a href=&quot;#二-让propertychange事件冒泡&quot; class=&quot;headerlink&quot; title=&quot;二.让propertychange事件冒泡&quot;&gt;&lt;/a&gt;二.让propertychange事件冒泡&lt;/h1&gt;&lt;p&gt;　　这个需要是否有点强IE8所难呢？的确，该事件本身是并不支持的，那我们只能想点歪门斜道了，通过监听”focusin”来变通实现&lt;br&gt;&lt;br&gt;实现思路如下:&lt;/p&gt;
&lt;p&gt;　　这种需求一般是想要进行事件托管，通过监听表单元素的父级或者document/window对象来方便托管一切表单元素，这种实现方式稳定又高效，但这一切是基于该事件能够冒泡到顶层。虽然propertychange事件不支持冒泡，但”focusin”事件是支持的不过它俩的职责不同啊，一个是监听属性变化，一个是监听焦点变化，如何联系？&lt;/p&gt;
&lt;p&gt;　　大家想一下，如果要模拟input事件，一切的事件触发都是基于用户的输入，但输入之前必然得先让表单元素获取焦点，那是否可以这样，当输入框获取焦点的时候再绑定propertychange呢？&lt;/p&gt;
&lt;p&gt;上代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;document.onfocusin=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //target即为此时获取焦点的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var target=e.srcElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里再保证一下此时该元素确实获取焦点(focusin事件也有坑爹的地方，暂且不表)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(document.activeElement == target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;三-让propertychange过滤js对值的改变&quot;&gt;&lt;a href=&quot;#三-让propertychange过滤js对值的改变&quot; class=&quot;headerlink&quot; title=&quot;三.让propertychange过滤js对值的改变&quot;&gt;&lt;/a&gt;三.让propertychange过滤js对值的改变&lt;/h1&gt;&lt;p&gt;　　这条我觉得才是重头戏！网上也有相关实现，但解决方案无非两种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;干脆就不监听propertychange，通过监听表单元素的”keydown”,”cut”,”paste”等一系列输入事件来模拟&lt;/li&gt;
&lt;li&gt;在js设置value之前先主动告诉某变量我正在用js改变value，propertychange于是忽略。于是你在每次用js设置值之前都得先设置那个全局变量先&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　好吧，我就不喷了，直接上我的解决办法，通过使用大家很少会用到的api:&lt;a href=&quot;http://www.2cto.com/kf/201410/346904.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;defineProperty(点我查看用途)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果你已经了解了defineProperty，我估计你已经知道我接下来要干啥了。&lt;/p&gt;
&lt;p&gt;　　其实思路说出来很简单，就是如果在js改变表单元素值的时候，能自动通知我不就完事大吉了吗？而defineProperty就是干这事的！啊，不对，应该是一不小心干了这事。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误代码如下，错误代码如下，错误代码如下(重要的事情说三遍)&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(input,&amp;quot;value&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    set:function(val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.value=val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　为什么上面的代码是错的？因为会无限递归(好一个自问自答==)。由代码可以看出，在set方法的内部又调用了this.value=xx,于是就会继续再调用set，所以无限递归了。为毛非得”this.value=xx”呢，因为不这样的话，项目中的如下代码就会彻底失效了:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input.value=&amp;quot;我是单身狗，汪汪汪&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;方法总比困难多，机智的我又想到另外一种设置value的办法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input.setAttribute(&amp;quot;value&amp;quot;,&amp;quot;我是单身狗，汪汪汪&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ok,那再修改一下上面的代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还是错误代码如下，错误代码如下，错误代码如下(重要的事情说三遍)&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(input,&amp;quot;value&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    set:function(val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.setAttribute(&amp;quot;value&amp;quot;,val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.getAttribute(&amp;quot;value&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　那么问题来了，为毛上面的代码还错啊？！我特么又要自言自语了。.听我仔细分析:&lt;br&gt;　　当js对表单元素设置值的时候，首先会触发defineProperty中对value定义的set方法，然后代码走啊走啊，当走到:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;this.setAttribute(&amp;quot;value&amp;quot;,val);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　这一行的时候，代码就会立刻跳到input.onpropertychange方法中去。。也就是说你还没来得及设置setValByJs呢，事件就被捕获了,故而对于托管方法来说，setValByJs的值是啥永远是后知后觉的。为什么我会了解这么清楚？好吧，这都是我那时候遇到的坑，出于大家坑才是真的坑的心态，故放出来大家一起坑。所以上面的代码只需要把:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setValByJs=true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　移到set方法的第一行即可。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本正确的代码如下&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//我是那个用来判断是否是js改变表单元素值的全局变量setValByJs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(input,&amp;quot;value&amp;quot;,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    set:function(val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.setAttribute(&amp;quot;value&amp;quot;,val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get:function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.getAttribute(&amp;quot;value&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input.onpropertychange=function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(e.propertyName == &amp;quot;value&amp;quot; || e.propertyName == &amp;quot;selectedIndex&amp;quot;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　为什么又是基本正确呢？因为以上的例子基本全是事件的单一绑定，多绑定的坑还有很多。&lt;br&gt;这里提一点最容易被坑的吧,就是这段代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　如果该表单元素的propertychange事件绑定了多个监听方法，只有第一个方法里会获取到setValByJs的正确值，后面的获取到的永远都是false.大家好好看下代码便知原因。这种情况也是得用点歪门斜道解决:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(setValByJs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setValByJs=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里写事件处理即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　而且以上代码没有覆盖到所有表单元素，比如上文中提到的下拉选择框，它一般不直接监听”value”，不过核心思路都在这了，希望对你有用！希望世上再没有IE！阿门&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;　&lt;br&gt;    其实之前有写过IE8兼容插件&lt;a href=&quot;https://github.com/aweiu/JsLibs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fixJSForIE8&lt;/a&gt;通过它可以让ie8兼容各种js的新特性并无须更改现有代码。只是目前该插件正在重构中，老的版本还并不能完美模拟”oninput”以及写得很烂。。着急的话可以先凑合用。主要目前缺少IE8的测试机器(不想装虚拟机)一旦更新，我会推送的。那就关注我的git吧~&lt;br&gt;&lt;/div&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;　　哈喽，前端的小伙伴们！在聊今天的IE兼容之前，还是先跟我一起问候下(日了)ie的所有版本吧！&lt;br&gt;　　在现代浏览器中，对表单元素的输入监听一般是通过监听”input”事件来实现，但坑爹的是ie8及之前的版本是不支持这个事件的,基本会使用它的替代品——“propertychange”来模拟这个事件，但模拟总归是模拟，如下是我总结的它们之间的最大区别&lt;br&gt;
    
    </summary>
    
    
      <category term="IE8兼容" scheme="http://aweiu.com/tags/IE8%E5%85%BC%E5%AE%B9/"/>
    
      <category term="IE8监听oninput" scheme="http://aweiu.com/tags/IE8%E7%9B%91%E5%90%AConinput/"/>
    
      <category term="propertychange忽略js" scheme="http://aweiu.com/tags/propertychange%E5%BF%BD%E7%95%A5js/"/>
    
  </entry>
  
  <entry>
    <title>喜马拉雅黑科技——无卡顿网页播放器</title>
    <link href="http://aweiu.com/2016/04/18/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85%E9%BB%91%E7%A7%91%E6%8A%80%E2%80%94%E2%80%94%E6%97%A0%E5%8D%A1%E9%A1%BF%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://aweiu.com/2016/04/18/喜马拉雅黑科技——无卡顿网页播放器/</id>
    <published>2016-04-18T07:04:55.000Z</published>
    <updated>2016-04-21T03:00:17.268Z</updated>
    
    <content type="html">&lt;p&gt;　　某天上班，偶然打开网页版的喜马拉雅，随手点了首推荐音频。。。于是伴随着动词大词，动词大词，继续逛着它的首页。&lt;br&gt;　　一个不小心，又点进了老郭的相声，哎，还是木有更新，不过老段子也可以再听听，正当老夫要点播的时候，突然！哎呀！卧槽！卧槽！牛逼啊！我都逛了这么多页面了，耳机里的”动词大词”竟然连顿都没打，当时还打开了一下本地播放器，以为是它播放的音乐。&lt;br&gt;　　详细情形是这样的：我在喜马拉雅的&lt;strong&gt;a页面&lt;/strong&gt;播放了音乐，然后又去&lt;strong&gt;b页面&lt;/strong&gt;，&lt;strong&gt;c页面&lt;/strong&gt;，音乐却并没有卡顿现象，稳如死狗！注意，这里说的是连卡顿都没有，不是说跳到别的页面会继续播放。&lt;br&gt;　　国内的在线音乐平台有很多，实现喜马拉雅的这种哥还是头一回见啊。大部分都是采取的本地缓存音乐进度，跳到别的页面再读取进度，继续播放，但切页面的时候肯定是会有卡顿的。所以这里给喜马拉雅的用户体验32个赞！&lt;br&gt;　　那么问题来了，这种网页播放器是如何实现的？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;　　简单点说，其实就是使用了html5的api:&lt;a href=&quot;http://www.cnblogs.com/flash3d/archive/2013/10/23/3384823.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;history.pushstate&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;页面中，所有的a标签，js对其做了点击事件的拦截，如果是支持该API的浏览器不会发生跳转，而是通过ajax请求该链接，返回结果是一串类似于如下的json:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;html&amp;quot;:&amp;quot;&amp;lt;div class=&amp;apos;xxx&amp;apos;&amp;gt;xxx&amp;lt;/div&amp;gt;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;quot;title&amp;quot;:&amp;quot;页面标题&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;通过js将html里的内容插入到页面的指定容器中去&lt;/li&gt;
&lt;li&gt;使用histoyr.pushstate，强势插入一条浏览历史&lt;br&gt;　　于是当前浏览器的页面内容会被更新,访问地址会变成该a标签的链接，页面标题变成返回结果中的title。所以看起来就会和跳转页面一样，但实际上页面并未发生过任何跳转，至始至终都是在一个页面中进行各种ajax请求而已，所以歌曲的播放当然不会卡顿了。&lt;br&gt;　　好了，揭秘完毕！小伙伴们是不是也可以使用上述步骤来创建自己的单页应用了呢？别急，待我先喷一喷这种单页应用的缺点先！&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;需要后端配合渲染页面。区分ajax请求和浏览器请求，即如果是ajax请求页面，则返回上述json，否则正常返回整个页面内容以供跳转。&lt;/li&gt;
&lt;li&gt;需要js/css路由(某些框架就可以实现)或初次载入即加载完所有js/css，并解决冲突。&lt;br&gt;　　因为ajax请求返回的仅仅是html部分，没有也不能够包含页面对应的js/css，一旦包含了，很可能就会形成全局变量冲突，事件冲突，样式混乱等问题，请求的页面越多，问题越严重！这对于前端的小伙伴来说真是日了狗了。。没法再轻松愉快的维护各自页面各自的静态资源了，写着a页面还得操着b页面的心，遵循一堆约定。而且本人也比较反感因为使用了某些框架（比如:react.js）就要放弃html各种纯天然的写法，毕竟原生态的，才是我们最熟悉的。&lt;/li&gt;
&lt;li&gt;感觉两条太少了，凑个数行不。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&quot;tip&quot;&gt;　&lt;br&gt;    我知道，看到这里肯定有人想喷我了。时代在进步，现在前端各种mvc框架完全能够实现这种需求，为毛还嫌麻烦？我想说，每种框架都&lt;br&gt;有它的适用情景，也都有值得我们学习的地方，but！每个团队的开发模式，编程水平，项目时间都不同，适合自己的才是最好的。并且现代&lt;br&gt;浏览器的性能，人们的带宽都取得了长足的进步，有时候为了一点性能提升而要改变适合整个团队的编码习惯，是不是有点舍近求远了呢？&lt;br&gt;&lt;/div&gt;&lt;br&gt;　　而优点当然也有了，就1条！&lt;/p&gt;
&lt;p&gt;　　太特么省流量了。因为各个页面会有很多相同部分，ajax仅返回异同部分即可，所以页面的体验会更加流畅，并可以有效减少http请求。。好像不止1条，不管了。&lt;/p&gt;
&lt;p&gt;　　那么接着html原生写法的思路，有没有一种方式能够让我们不用管前后端配合，也不用鸟静态资源路由，就像做多页站点那样无痛创建单页应用呢？相信你脑海中已经出现那个古老科技了，对！就是&lt;strong&gt;iframe&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用iframe将页面包起来&lt;/li&gt;
&lt;li&gt;播放器给挪到外面去&lt;br&gt;　　　　这样iframe中的页面爱咋跳咋跳，同样也不会影响到外面播放器的运行&lt;/li&gt;
&lt;li&gt;使用html5的另一个API:history.replacestate改改浏览器地址，改改标题&lt;/li&gt;
&lt;li&gt;iframe的跳转又天然会插入一条浏览历史&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简直完美！&lt;/p&gt;
&lt;p&gt;　　利用以上原理，鄙人写了一个插件—— &lt;a href=&quot;https://github.com/328080339/JsLibs/wiki/singlePage.js%28%E6%9B%B4%E8%87%AA%E7%84%B6%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;singlePage.js(点我查看文档)&lt;/a&gt;&lt;br&gt;　　帮助大家更自然地创建单页应用，没有那么多的屁事儿，你要做的仅仅只有一步，引入它！&lt;br&gt;　　&lt;a href=&quot;http://awei.oss-cn-shenzhen.aliyuncs.com/singlePage/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查看演示(仿喜马拉雅播放器)&lt;/a&gt;
　　&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　某天上班，偶然打开网页版的喜马拉雅，随手点了首推荐音频。。。于是伴随着动词大词，动词大词，继续逛着它的首页。&lt;br&gt;　　一个不小心，又点进了老郭的相声，哎，还是木有更新，不过老段子也可以再听听，正当老夫要点播的时候，突然！哎呀！卧槽！卧槽！牛逼啊！我都逛了这么多页面了，耳机里的”动词大词”竟然连顿都没打，当时还打开了一下本地播放器，以为是它播放的音乐。&lt;br&gt;　　详细情形是这样的：我在喜马拉雅的&lt;strong&gt;a页面&lt;/strong&gt;播放了音乐，然后又去&lt;strong&gt;b页面&lt;/strong&gt;，&lt;strong&gt;c页面&lt;/strong&gt;，音乐却并没有卡顿现象，稳如死狗！注意，这里说的是连卡顿都没有，不是说跳到别的页面会继续播放。&lt;br&gt;　　国内的在线音乐平台有很多，实现喜马拉雅的这种哥还是头一回见啊。大部分都是采取的本地缓存音乐进度，跳到别的页面再读取进度，继续播放，但切页面的时候肯定是会有卡顿的。所以这里给喜马拉雅的用户体验32个赞！&lt;br&gt;　　那么问题来了，这种网页播放器是如何实现的？&lt;br&gt;
    
    </summary>
    
    
      <category term="喜马拉雅播放器" scheme="http://aweiu.com/tags/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
      <category term="单页应用" scheme="http://aweiu.com/tags/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
    
      <category term="singlePage" scheme="http://aweiu.com/tags/singlePage/"/>
    
  </entry>
  
</feed>
